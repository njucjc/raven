/*
 * Copyright 2022 The OpenYurt Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package vxlan

import (
	"bytes"
	"fmt"
	"math"
	"net"
	"os"
	"strings"
	"syscall"
	"time"

	"github.com/vdobler/ht/errorlist"
	"github.com/vishvananda/netlink"
	"k8s.io/klog/v2"

	"github.com/openyurtio/api/raven/v1beta1"
	"github.com/openyurtio/raven/cmd/agent/app/config"
	"github.com/openyurtio/raven/pkg/networkengine/routedriver"
	networkutil "github.com/openyurtio/raven/pkg/networkengine/util"
	ipsetutil "github.com/openyurtio/raven/pkg/networkengine/util/ipset"
	iptablesutil "github.com/openyurtio/raven/pkg/networkengine/util/iptables"
	"github.com/openyurtio/raven/pkg/types"
)

const (
	routeTableID = 9027 // yurt
	rulePriority = 100

	vxlanLinkName = "raven0"
	vxlanEncapLen = 50
	vxlanID       = 200
	vxlanPort     = 4472
	vxlanGwPrefix = 240

	DriverName = "vxlan"

	ravenMark = 0x40

	ravenMarkSet     = "raven-mark-set"
	ravenMarkSetType = "hash:net"
)

var (
	nonGatewayChainRuleSpec = []string{"-m", "set", "--match-set", ravenMarkSet, "dst", "-m", "comment", "--comment", "raven traffic requiring certain mark", "-j", "MARK", "--set-mark", fmt.Sprintf("%d", ravenMark)}
	gatewayChainRuleSpec    = []string{"-m", "set", "--match-set", ravenMarkSet, "src", "-m", "comment", "--comment", "raven traffic requiring certain mark", "-j", "MARK", "--set-mark", fmt.Sprintf("%d", ravenMark)}
)

func init() {
	routedriver.RegisterRouteDriver(DriverName, New)
}

type vxlan struct {
	vxlanIface netlink.Link
	nodeName   types.NodeName
	macPrefix  string

	iptables iptablesutil.IPTablesInterface
	ipset    ipsetutil.IPSetInterface
}

func (vx *vxlan) Apply(network *types.Network, vpnDriverMTUFn func() (int, error)) (err error) {
	if network.LocalEndpoint == nil || len(network.RemoteEndpoints) == 0 {
		klog.Info("no local gateway or remote gateway is found, cleaning up route setting")
		return vx.Cleanup()
	}
	if len(network.LocalNodeInfo) == 1 {
		klog.Info("only gateway node exist in current gateway, cleaning up route setting")
		return vx.Cleanup()
	}

	// The desired and current routes calculated from given network.
	// The key is generated by routeKey().
	var desiredRoutes, currentRoutes map[string]*netlink.Route

	// The desired and current rules calculated from given network.
	// The key is generated by ruleKey().
	var desiredRules, currentRules map[string]*netlink.Rule

	// The desired and current FDB entries calculated from given network.
	// The key is NeighKey()
	var desiredFDBs, currentFDBs map[string]*netlink.Neigh

	// The desired and current ARP entries calculated from given network.
	// The key is NeighKey()
	var desiredARPs, currentARPs map[string]*netlink.Neigh

	// The desired and current ipset entries calculated from given network.
	// The key is ip set entry
	var desiredSet, currentSet map[string]*netlink.IPSetEntry
	vx.ipset, err = ipsetutil.New(ravenMarkSet, ravenMarkSetType, ipsetutil.IpsetWrapperOption{})
	if err != nil {
		return fmt.Errorf("error create ip set: %s", err)
	}

	err = vx.ensureRavenChain()
	if err != nil {
		return fmt.Errorf("error ensure raven mark chain: %s", err)
	}

	err = vx.ensureVxlanLink(network, vpnDriverMTUFn)
	if err != nil {
		return fmt.Errorf("error ensuring vxlan: %s", err)
	}

	currentRoutes, err = networkutil.ListRoutesOnNode(routeTableID)
	if err != nil {
		return fmt.Errorf("error listing routes on node: %s", err)
	}
	currentRules, err = networkutil.ListRulesOnNode(routeTableID)
	if err != nil {
		return fmt.Errorf("error listing rules on node: %s", err)
	}

	currentFDBs, err = networkutil.ListFDBsOnNode(vx.vxlanIface)
	if err != nil {
		return fmt.Errorf("error listing fdb on node: %s", err)
	}

	currentARPs, err = networkutil.ListARPsOnNode(vx.vxlanIface)
	if err != nil {
		return fmt.Errorf("error listing arp on node: %s", err)
	}

	currentSet, err = networkutil.ListIPSetOnNode(vx.ipset)
	if err != nil {
		return fmt.Errorf("error listing ip set on node: %s", err)
	}

	desiredSet = vx.calIPSetOnNode(network)
	desiredRules = vx.calRulesOnNode()

	if vx.isGatewayRole(network) {
		desiredRoutes = vx.calRouteOnGateway(network)
		desiredFDBs, err = vx.calFDBOnGateway(network)
		if err != nil {
			return fmt.Errorf("error calculate gateway fdb: %s", err)
		}
		desiredARPs, err = vx.calARPOnGateway(network)
		if err != nil {
			return fmt.Errorf("error calculate gateway arp: %s", err)
		}
		err = vx.deleteChainRuleOnNode(iptablesutil.MangleTable, iptablesutil.RavenMarkChain, nonGatewayChainRuleSpec)
		if err != nil {
			return fmt.Errorf("error deleting non gateway chain rule: %s", err)
		}
		err = vx.addChainRuleOnNode(iptablesutil.MangleTable, iptablesutil.RavenMarkChain, gatewayChainRuleSpec)
		if err != nil {
			return fmt.Errorf("error adding gateway chain rule: %s", err)
		}
	} else {
		desiredRoutes = vx.calRouteOnNonGateway(network)
		desiredFDBs, err = vx.calFDBOnNonGateway(network)
		if err != nil {
			return fmt.Errorf("error calculate non gateway fdb: %s", err)
		}
		desiredARPs, err = vx.calARPOnNonGateway(network)
		if err != nil {
			return fmt.Errorf("error calculate non gateway arp: %s", err)
		}
		err = vx.deleteChainRuleOnNode(iptablesutil.MangleTable, iptablesutil.RavenMarkChain, gatewayChainRuleSpec)
		if err != nil {
			return fmt.Errorf("error deleting gateway chain rule: %s", err)
		}
		err = vx.addChainRuleOnNode(iptablesutil.MangleTable, iptablesutil.RavenMarkChain, nonGatewayChainRuleSpec)
		if err != nil {
			return fmt.Errorf("error adding non gateway chain rule: %s", err)
		}
	}

	err = networkutil.ApplyRoutes(currentRoutes, desiredRoutes)
	if err != nil {
		return fmt.Errorf("error applying routes: %s", err)
	}
	err = networkutil.ApplyRules(currentRules, desiredRules)
	if err != nil {
		return fmt.Errorf("error applying rules: %s", err)
	}
	err = networkutil.ApplyFDBs(currentFDBs, desiredFDBs)
	if err != nil {
		return fmt.Errorf("error applying fdb: %s", err)
	}
	err = networkutil.ApplyARPs(currentARPs, desiredARPs)
	if err != nil {
		return fmt.Errorf("error applying arp: %s", err)
	}
	err = networkutil.ApplyIPSet(vx.ipset, currentSet, desiredSet)
	if err != nil {
		return fmt.Errorf("error applying ip set: %s", err)
	}

	return nil
}

func (vx *vxlan) MTU(network *types.Network) (int, error) {
	// The default link to other nodes in the gateway.
	var defaultLink netlink.Link
	var err error
	if vx.isGatewayRole(network) {
		// Only one node, vxlan interface is ignored
		if len(network.LocalNodeInfo) == 1 {
			return math.MaxInt, nil
		}
		for nodeName, v := range network.LocalNodeInfo {
			if nodeName != vx.nodeName {
				defaultLink, err = defaultLinkTo(net.ParseIP(v.PrivateIP))
				if err != nil {
					return 0, fmt.Errorf("error getting default link to: %s, %s", v.PrivateIP, err)
				}
				break
			}
		}
	} else {
		defaultLink, err = defaultLinkTo(net.ParseIP(network.LocalEndpoint.PrivateIP))
		if err != nil {
			return 0, fmt.Errorf("error getting default link to: %s, %s", network.LocalEndpoint.PrivateIP, err)
		}
	}
	if defaultLink == nil {
		return 0, fmt.Errorf("cannot find default link")
	}
	return defaultLink.Attrs().MTU - vxlanEncapLen, nil
}

// nodeInfo returns node info of the current node.
func (vx *vxlan) nodeInfo(network *types.Network) *v1beta1.NodeInfo {
	return network.LocalNodeInfo[vx.nodeName]
}

func New(cfg *config.Config) (routedriver.Driver, error) {
	return &vxlan{
		nodeName:  types.NodeName(cfg.NodeName),
		macPrefix: cfg.Tunnel.MACPrefix,
	}, nil
}

func (vx *vxlan) Init() (err error) {
	vx.iptables, err = iptablesutil.New()
	if err != nil {
		return err
	}

	vx.ipset, err = ipsetutil.New(ravenMarkSet, ravenMarkSetType, ipsetutil.IpsetWrapperOption{})
	if err != nil {
		return err
	}
	return
}

func (vx *vxlan) ensureRavenChain() error {
	// for raven mark
	if err := vx.iptables.NewChainIfNotExist(iptablesutil.MangleTable, iptablesutil.RavenMarkChain); err != nil {
		return fmt.Errorf("error create %s chain: %s", iptablesutil.RavenMarkChain, err)
	}
	if err := vx.iptables.AppendIfNotExists(iptablesutil.MangleTable, iptablesutil.PreRoutingChain, "-m", "comment", "--comment", "raven traffic rules for mark", "-j", iptablesutil.RavenMarkChain); err != nil {
		return fmt.Errorf("error adding chain %s rule: %s", iptablesutil.PreRoutingChain, err)
	}
	if err := vx.iptables.AppendIfNotExists(iptablesutil.MangleTable, iptablesutil.OutputChain, "-m", "comment", "--comment", "raven traffic rules for mark", "-j", iptablesutil.RavenMarkChain); err != nil {
		return fmt.Errorf("error adding chain %s rule: %s", iptablesutil.OutputChain, err)
	}

	return nil
}

func (vx *vxlan) ensureVxlanLink(network *types.Network, vpnDriverMTUFn func() (int, error)) (err error) {
	var vpnDriverMTU, routeDriverMTU int
	vpnDriverMTU, err = vpnDriverMTUFn()
	if err != nil {
		return err
	}
	routeDriverMTU, err = vx.MTU(network)
	if err != nil {
		return err
	}
	vxlanLink := netlink.Vxlan{
		LinkAttrs: netlink.LinkAttrs{
			Name: vxlanLinkName,
			MTU: func(a, b int) int {
				if a > b {
					return b
				}
				return a
			}(vpnDriverMTU, routeDriverMTU),
			Flags: net.FlagUp,
		},
		VxlanId:  vxlanID,
		Age:      300,
		Port:     vxlanPort,
		Learning: false,
	}
	if !vx.isGatewayRole(network) {
		vxlanLink.Group = net.ParseIP(network.LocalEndpoint.PrivateIP)
	}

	localIP := net.ParseIP(vx.nodeInfo(network).PrivateIP)
	vxlanLink.HardwareAddr, err = vx.ipAddrToHardwareAddr(localIP)
	if err != nil {
		return fmt.Errorf("error convert vxlan ip to mac address: %s", err)
	}
	nl, err := ensureVxlanLink(vxlanLink, vxlanIP(localIP))
	if err != nil {
		return fmt.Errorf("error ensuring vxlan link: %s", err)
	}
	vx.vxlanIface = nl
	//Enable loose mode (rp_filter=2) reverse path filtering on the raven0 interface.
	err = setSysctl("/proc/sys/net/ipv4/conf/"+vxlanLinkName+"/rp_filter", []byte("2"))
	if err != nil {
		return fmt.Errorf("error setSysctl: %s", err)
	}
	return nil

}

func setSysctl(path string, contents []byte) error {
	existing, err := os.ReadFile(path)
	if err != nil {
		return err
	}

	// Ignore leading and terminating newlines
	existing = bytes.Trim(existing, "\n")

	if bytes.Equal(existing, contents) {
		return nil
	}
	// Permissions are already 644, the files are never created
	// #nosec G306
	return os.WriteFile(path, contents, 0o644)
}

// calRouteOnNonGateway calculates and returns the desired routes on non-gateway node.
// Routes on non-gateway node will use a separate route table(raven route table),
// and configure the local gateway node as the next hop for packets sending to remote gateway nodes.
// The routes entries format are equivalent to the following `ip route` command:
//
//	ip route add default via {local_gateway_raven0_ip} dev raven0 onlink mtu {mtu} table {routeTableID}
func (vx *vxlan) calRouteOnNonGateway(network *types.Network) map[string]*netlink.Route {
	routes := make(map[string]*netlink.Route)
	via := vxlanIP(net.ParseIP(network.LocalEndpoint.PrivateIP))
	defaultNR := &netlink.Route{
		LinkIndex: vx.vxlanIface.Attrs().Index,
		Scope:     netlink.SCOPE_UNIVERSE,
		Gw:        via,
		Table:     routeTableID,
		Flags:     int(netlink.FLAG_ONLINK),
		MTU:       vx.vxlanIface.Attrs().MTU,
	}
	routes[networkutil.RouteKey(defaultNR)] = defaultNR
	return routes
}

// calRouteOnGateway calculates and returns the desired routes on gateway.
// Routes on gateway node are used to configure the reverse-path route for packets from local non-gateway nodes to remote nodes,
// to avoid asymmetric routing.
// The routes entries format are equivalent to the following `ip route` command:
//
//	ip route add {non_gateway_nodeN_cidr} via {non_gateway_nodeN_raven0_ip} dev raven0 onlink mtu {mtu} table {routeTableID}
func (vx *vxlan) calRouteOnGateway(network *types.Network) map[string]*netlink.Route {
	routes := make(map[string]*netlink.Route)
	for _, v := range network.LocalNodeInfo {
		if types.NodeName(v.NodeName) == vx.nodeName {
			continue
		}
		for _, dstCIDR := range v.Subnets {
			_, dst, err := net.ParseCIDR(dstCIDR)
			if err != nil {
				klog.ErrorS(err, "error parsing cidr", "cidr", dst)
				continue
			}
			via := vxlanIP(net.ParseIP(v.PrivateIP))
			nr := &netlink.Route{
				LinkIndex: vx.vxlanIface.Attrs().Index,
				Scope:     netlink.SCOPE_UNIVERSE,
				Dst:       dst,
				Gw:        via,
				Table:     routeTableID,
				Flags:     int(netlink.FLAG_ONLINK),
				MTU:       vx.vxlanIface.Attrs().MTU,
			}
			routes[networkutil.RouteKey(nr)] = nr
		}
	}
	return routes
}

// calRulesOnNode calculates and returns the desired rules on node.
// Rules on gateway node are used to configure route policy for the reverse-path route.
// The rules format are equivalent to the following `ip rule` command:
//
//	ip rule add from all fwmark 0x40 lookup {routeTableID} prio {rulePriority}
func (vx *vxlan) calRulesOnNode() map[string]*netlink.Rule {
	rules := make(map[string]*netlink.Rule)
	rule := networkutil.NewRavenRule(rulePriority, routeTableID)
	rule.Mark = ravenMark
	rules[networkutil.RuleKey(rule)] = rule
	return rules
}

// calFDBOnGateway calculates and returns the desired FDB entries on gateway node.
// The FDB entries format are equivalent to the following `bridge fdb append` command:
//
//	bridge fdb append fixed mac address dev raven0 dst {non_gateway_nodeN_private_ip} self permanent
func (vx *vxlan) calFDBOnGateway(network *types.Network) (map[string]*netlink.Neigh, error) {
	fdbs := make(map[string]*netlink.Neigh)
	for k, v := range network.LocalNodeInfo {
		if vx.nodeName == k {
			continue
		}
		HardwareAddr, err := vx.ipAddrToHardwareAddr(net.ParseIP(v.PrivateIP))
		if err != nil {
			return nil, fmt.Errorf("convert ip address %s to hardware address error %s", v.PrivateIP, err.Error())
		}
		nh := &netlink.Neigh{
			LinkIndex:    vx.vxlanIface.Attrs().Index,
			State:        netlink.NUD_PERMANENT | netlink.NUD_NOARP,
			Type:         netlink.NDA_DST,
			Family:       syscall.AF_BRIDGE,
			Flags:        netlink.NTF_SELF,
			IP:           net.ParseIP(v.PrivateIP),
			HardwareAddr: HardwareAddr,
		}
		fdbs[networkutil.NeighKey(nh)] = nh
	}
	return fdbs, nil
}

// calFDBOnNonGateway calculates and returns the desired FDB entries on non-gateway node.
// The FDB entries format are equivalent to the following `bridge fdb append` command:
//
//	bridge fdb append fixed mac address dev raven0 dst {gateway_node_private_ip} self permanent
func (vx *vxlan) calFDBOnNonGateway(network *types.Network) (map[string]*netlink.Neigh, error) {
	HardwareAddr, err := vx.ipAddrToHardwareAddr(net.ParseIP(network.LocalEndpoint.PrivateIP))
	if err != nil {
		return nil, fmt.Errorf("convert ip address %s to hardware address error %s", network.LocalEndpoint.PrivateIP, err.Error())
	}
	nh := &netlink.Neigh{
		LinkIndex:    vx.vxlanIface.Attrs().Index,
		State:        netlink.NUD_PERMANENT | netlink.NUD_NOARP,
		Type:         netlink.NDA_DST,
		Family:       syscall.AF_BRIDGE,
		Flags:        netlink.NTF_SELF,
		IP:           net.ParseIP(network.LocalEndpoint.PrivateIP),
		HardwareAddr: HardwareAddr,
	}
	return map[string]*netlink.Neigh{networkutil.NeighKey(nh): nh}, nil
}

// calARPOnGateway calculates and returns the desired ARP entries on gateway node.
// The ARP entries format are equivalent to the following `ip neigh` command:
func (vx *vxlan) calARPOnGateway(network *types.Network) (map[string]*netlink.Neigh, error) {
	arps := make(map[string]*netlink.Neigh)
	for k, v := range network.LocalNodeInfo {
		if vx.nodeName == k {
			continue
		}
		HardwareAddr, err := vx.ipAddrToHardwareAddr(net.ParseIP(v.PrivateIP))
		if err != nil {
			return nil, fmt.Errorf("convert ip address %s to hardware address error %s", v.PrivateIP, err.Error())
		}
		nh := &netlink.Neigh{
			LinkIndex:    vx.vxlanIface.Attrs().Index,
			State:        netlink.NUD_PERMANENT,
			Type:         netlink.NDA_DST,
			Family:       syscall.AF_INET,
			Flags:        netlink.NTF_SELF,
			IP:           vxlanIP(net.ParseIP(v.PrivateIP)),
			HardwareAddr: HardwareAddr,
		}
		arps[networkutil.NeighKey(nh)] = nh
	}
	return arps, nil
}

// calARPOnNonGateway calculates and returns the desired ARP entries on non-gateway node.
// The ARP entries format are equivalent to the following `ip neigh` command:
func (vx *vxlan) calARPOnNonGateway(network *types.Network) (map[string]*netlink.Neigh, error) {
	HardwareAddr, err := vx.ipAddrToHardwareAddr(net.ParseIP(network.LocalEndpoint.PrivateIP))
	if err != nil {
		return nil, fmt.Errorf("convert ip address %s to hardware address error %s", network.LocalEndpoint.PrivateIP, err.Error())
	}
	nh := &netlink.Neigh{
		LinkIndex:    vx.vxlanIface.Attrs().Index,
		State:        netlink.NUD_PERMANENT,
		Type:         netlink.NDA_DST,
		Family:       syscall.AF_INET,
		Flags:        netlink.NTF_SELF,
		IP:           vxlanIP(net.ParseIP(network.LocalEndpoint.PrivateIP)),
		HardwareAddr: HardwareAddr,
	}
	return map[string]*netlink.Neigh{networkutil.NeighKey(nh): nh}, nil
}

// calIPSetOnNonGateway calculates and returns the desired ip set entries on non-gateway node.
// The ip set entries format equivalent to the following `ipset add SETNAME ENTRY` command:
//
//	ipset add raven-egress-set {remote_nodeN_subnet_cidr}
func (vx *vxlan) calIPSetOnNode(network *types.Network) map[string]*netlink.IPSetEntry {
	set := make(map[string]*netlink.IPSetEntry)
	for _, v := range network.RemoteNodeInfo {
		nodeInfo := network.RemoteNodeInfo[types.NodeName(v.NodeName)]
		if nodeInfo == nil {
			klog.Errorf("node %s not found in RemoteNodeInfo", v.NodeName)
			continue
		}
		for _, srcCIDR := range nodeInfo.Subnets {
			_, ipNet, err := net.ParseCIDR(srcCIDR)
			if err != nil {
				klog.Errorf("parse node subnet %s error %s", srcCIDR, err.Error())
				continue
			}
			ones, _ := ipNet.Mask.Size()
			entry := &netlink.IPSetEntry{
				IP:      ipNet.IP,
				CIDR:    uint8(ones),
				Replace: true,
			}
			set[vx.ipset.Key(entry)] = entry
		}
	}
	return set
}

func (vx *vxlan) Cleanup() error {
	errList := errorlist.List{}
	if err := networkutil.CleanRulesOnNode(routeTableID); err != nil {
		errList = errList.Append(err)
	}

	if err := networkutil.CleanRoutesOnNode(routeTableID); err != nil {
		errList = errList.Append(err)
	}

	if err := deleteVxlanLink(vxlanLinkName); err != nil {
		errList = errList.Append(err)
	}

	// Clean may be called more than one time, so we should ensure chain exists
	err := vx.iptables.NewChainIfNotExist(iptablesutil.MangleTable, iptablesutil.RavenMarkChain)
	if err != nil {
		errList = errList.Append(fmt.Errorf("error ensure chain %s: %s", iptablesutil.RavenMarkChain, err))
	}
	err = vx.iptables.DeleteIfExists(iptablesutil.MangleTable, iptablesutil.PreRoutingChain, "-m", "comment", "--comment", "raven traffic rules for mark", "-j", iptablesutil.RavenMarkChain)
	if err != nil {
		errList = errList.Append(fmt.Errorf("error deleting %s chain rule: %s", iptablesutil.PreRoutingChain, err))
	}
	err = vx.iptables.DeleteIfExists(iptablesutil.MangleTable, iptablesutil.OutputChain, "-m", "comment", "--comment", "raven traffic rules for mark", "-j", iptablesutil.RavenMarkChain)
	if err != nil {
		errList = errList.Append(fmt.Errorf("error deleting %s chain rule: %s", iptablesutil.OutputChain, err))
	}
	err = vx.iptables.ClearAndDeleteChain(iptablesutil.MangleTable, iptablesutil.RavenMarkChain)
	if err != nil {
		errList = errList.Append(fmt.Errorf("error deleting %s chain %s", iptablesutil.RavenMarkChain, err))
	}

	// Clean may be called more than one time, so we should ensure ip set exists
	vx.ipset, err = ipsetutil.New(ravenMarkSet, ravenMarkSetType, ipsetutil.IpsetWrapperOption{})
	if err != nil {
		errList = errList.Append(fmt.Errorf("error ensure ip set %s: %s", ravenMarkSet, err))
	}
	time.Sleep(time.Second)
	err = vx.ipset.Flush()
	if err != nil {
		errList = errList.Append(fmt.Errorf("error flushing ipset: %s", err))
	}
	time.Sleep(time.Second)
	err = vx.ipset.Destroy()
	if err != nil {
		errList = errList.Append(fmt.Errorf("error destroying ipset: %s", err))
	}
	return errList.AsError()
}

func (vx *vxlan) deleteChainRuleOnNode(table string, chain string, ruleSpec []string) error {
	if err := vx.iptables.DeleteIfExists(table, chain, ruleSpec...); err != nil {
		return fmt.Errorf("error deleting table %s chain %s rule %v: %s", table, chain, ruleSpec, err)
	}
	return nil
}

func (vx *vxlan) addChainRuleOnNode(table string, chain string, ruleSpec []string) error {
	if err := vx.iptables.AppendIfNotExists(table, chain, ruleSpec...); err != nil {
		return fmt.Errorf("error adding table %s chain %s rule %v: %s", table, chain, ruleSpec, err)
	}
	return nil
}

func vxlanIP(privateIP net.IP) net.IP {
	privateIP = privateIP.To4()
	vxlanIP := make(net.IP, 4)
	copy(vxlanIP, privateIP)
	vxlanIP[0] = vxlanGwPrefix
	return vxlanIP
}

func (vx *vxlan) isGatewayRole(network *types.Network) bool {
	return network != nil &&
		network.LocalEndpoint != nil &&
		network.LocalEndpoint.NodeName == vx.nodeName
}

func (vx *vxlan) ipAddrToHardwareAddr(ip net.IP) (net.HardwareAddr, error) {
	macSlice := []string{vx.macPrefix}
	for _, ipSlice := range vxlanIP(ip).To4() {
		macSlice = append(macSlice, fmt.Sprintf("%02x", ipSlice))
	}
	macStr := strings.Join(macSlice, ":")
	macAddr, err := net.ParseMAC(macStr)
	if err != nil {
		return nil, fmt.Errorf("parse MAC %s error %s", macStr, err.Error())
	}
	return macAddr, nil
}
