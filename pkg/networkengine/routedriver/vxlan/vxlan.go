/*
 * Copyright 2022 The OpenYurt Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package vxlan

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"math"
	"net"
	"syscall"

	"github.com/openyurtio/raven-controller-manager/pkg/ravencontroller/apis/raven/v1alpha1"
	"github.com/vdobler/ht/errorlist"
	"github.com/vishvananda/netlink"
	"k8s.io/klog/v2"

	"github.com/openyurtio/raven/cmd/agent/app/config"
	"github.com/openyurtio/raven/pkg/networkengine/routedriver"
	networkutil "github.com/openyurtio/raven/pkg/networkengine/util"
	netlinkutil "github.com/openyurtio/raven/pkg/networkengine/util/netlink"
	"github.com/openyurtio/raven/pkg/types"
)

const (
	routeTableID = 9027 // yurt
	rulePriority = 100

	vxlanLinkName = "raven0"
	vxlanEncapLen = 50
	vxlanID       = 200
	vxlanPort     = 4472
	vxlanGwPrefix = 240

	DriverName = "vxlan"
)

func init() {
	routedriver.RegisterRouteDriver(DriverName, New)
}

type vxlan struct {
	vxlanIface netlink.Link
	nodeName   types.NodeName
}

func (vx *vxlan) Apply(network *types.Network, vpnDriverMTUFn func() (int, error)) (err error) {
	if network.LocalEndpoint == nil || len(network.RemoteEndpoints) == 0 {
		klog.Info("no local gateway or remote gateway is found, cleaning up route setting")
		return vx.Cleanup()
	}
	if len(network.LocalNodeInfo) == 1 {
		klog.Infof("only gateway node exist in current gateway, cleaning up route setting")
		return vx.Cleanup()
	}

	// The desired and current routes calculated from given network.
	// The key is generated by routeKey().
	var desiredRoutes, currentRoutes map[string]*netlink.Route

	// The desired and current rules calculated from given network.
	// The key is generated by ruleKey().
	var desiredRules, currentRules map[string]*netlink.Rule

	// The desired and current FDB entries calculated from given network.
	// The key is netlink.Neigh.IP
	var desiredFDBs, currentFDBs map[string]*netlink.Neigh

	err = vx.ensureVxlanLink(network, vpnDriverMTUFn)
	if err != nil {
		return fmt.Errorf("error ensuring vxlan: %s", err)
	}

	currentRoutes, err = networkutil.ListRoutesOnNode(routeTableID)
	if err != nil {
		return fmt.Errorf("error listing routes on node: %s", err)
	}
	currentRules, err = networkutil.ListRulesOnNode(routeTableID)
	if err != nil {
		return fmt.Errorf("error listing rules on node: %s", err)
	}

	currentFDBs, err = networkutil.ListFDBsOnNode(vx.vxlanIface)
	if err != nil {
		return fmt.Errorf("error listing fdb on node: %s", err)
	}
	if vx.isGatewayRole(network) {
		desiredRoutes = vx.calRouteOnGateway(network)
		desiredRules = vx.calRulesOnGateway(network)
		desiredFDBs = vx.calFDBOnGateway(network)
	} else {
		desiredRoutes = vx.calRouteOnNonGateway(network)
		desiredRules = vx.calRulesOnNonGateway()
		desiredFDBs = vx.calFDBOnNonGateway(network)
	}

	err = networkutil.ApplyRoutes(currentRoutes, desiredRoutes)
	if err != nil {
		return fmt.Errorf("error applying routes: %s", err)
	}
	err = networkutil.ApplyRules(currentRules, desiredRules)
	if err != nil {
		return fmt.Errorf("error applying rules: %s", err)
	}
	err = networkutil.ApplyFDBs(currentFDBs, desiredFDBs)
	if err != nil {
		return fmt.Errorf("error applying fdb: %s", err)
	}

	return nil
}

func (vx *vxlan) MTU(network *types.Network) (int, error) {
	// The default link to other nodes in the gateway.
	var defaultLink netlink.Link
	var err error
	if vx.isGatewayRole(network) {
		// Only one node, vxlan interface is ignored
		if len(network.LocalNodeInfo) == 1 {
			return math.MaxInt, nil
		}
		for nodeName, v := range network.LocalNodeInfo {
			if nodeName != vx.nodeName {
				defaultLink, err = defaultLinkTo(net.ParseIP(v.PrivateIP))
				if err != nil {
					return 0, fmt.Errorf("error getting default link to: %s, %s", v.PrivateIP, err)
				}
				break
			}
		}
	} else {
		defaultLink, err = defaultLinkTo(net.ParseIP(network.LocalEndpoint.PrivateIP))
		if err != nil {
			return 0, fmt.Errorf("error getting default link to: %s, %s", network.LocalEndpoint.PrivateIP, err)
		}
	}
	if defaultLink == nil {
		return 0, fmt.Errorf("cannot find default link")
	}
	return defaultLink.Attrs().MTU - vxlanEncapLen, nil
}

// nodeInfo returns node info of the current node.
func (vx *vxlan) nodeInfo(network *types.Network) *v1alpha1.NodeInfo {
	return network.LocalNodeInfo[vx.nodeName]
}

func New(cfg *config.Config) (routedriver.Driver, error) {
	return &vxlan{
		nodeName: types.NodeName(cfg.NodeName),
	}, nil
}

func (vx *vxlan) Init() (err error) {
	return nil
}

func (vx *vxlan) ensureVxlanLink(network *types.Network, vpnDriverMTUFn func() (int, error)) (err error) {
	var vpnDriverMTU, routeDriverMTU int
	vpnDriverMTU, err = vpnDriverMTUFn()
	if err != nil {
		return err
	}
	routeDriverMTU, err = vx.MTU(network)
	if err != nil {
		return err
	}
	vxlanLink := netlink.Vxlan{
		LinkAttrs: netlink.LinkAttrs{
			Name: vxlanLinkName,
			MTU: func(a, b int) int {
				if a > b {
					return b
				}
				return a
			}(vpnDriverMTU, routeDriverMTU),
			Flags: net.FlagUp,
		},
		VxlanId: vxlanID,
		Age:     300,
		Port:    vxlanPort,
	}
	if !vx.isGatewayRole(network) {
		vxlanLink.Group = net.ParseIP(network.LocalEndpoint.PrivateIP)
	}

	localIP := net.ParseIP(vx.nodeInfo(network).PrivateIP)
	nl, err := ensureVxlanLink(vxlanLink, vxlanIP(localIP))
	if err != nil {
		return fmt.Errorf("error ensuring vxlan link: %s", err)
	}
	vx.vxlanIface = nl
	//Enable loose mode (rp_filter=2) reverse path filtering on the raven0 interface.
	err = setSysctl("/proc/sys/net/ipv4/conf/"+vxlanLinkName+"/rp_filter", []byte("2"))
	if err != nil {
		return fmt.Errorf("error setSysctl: %s", err)
	}
	return nil

}

func setSysctl(path string, contents []byte) error {
	existing, err := ioutil.ReadFile(path)
	if err != nil {
		return err
	}

	// Ignore leading and terminating newlines
	existing = bytes.Trim(existing, "\n")

	if bytes.Equal(existing, contents) {
		return nil
	}
	// Permissions are already 644, the files are never created
	// #nosec G306
	return ioutil.WriteFile(path, contents, 0o644)
}

// calRouteOnNonGateway calculates and returns the desired routes on non-gateway node.
// Routes on non-gateway node will use a separate route table(raven route table),
// and configure the local gateway node as the next hop for packets sending to remote gateway nodes.
// The routes entries format are equivalent to the following `ip route` command:
//   ip route add {remote_subnet} via {local_gateway_raven0_ip} dev raven0 src {node_cni_ip} onlink mtu {mtu} table {routeTableID}
func (vx *vxlan) calRouteOnNonGateway(network *types.Network) map[string]*netlink.Route {
	routes := make(map[string]*netlink.Route)
	var src net.IP
	srcCIDR := vx.nodeInfo(network).Subnet
	src, _, err := net.ParseCIDR(srcCIDR)
	if err != nil {
		klog.ErrorS(err, "error parsing cidr", "cidr", srcCIDR)
		return routes
	}

	via := vxlanIP(net.ParseIP(network.LocalEndpoint.PrivateIP))
	for _, endpoints := range network.RemoteEndpoints {
		for _, v := range endpoints {
			for _, dstCIDR := range v.Subnets {
				_, ipnet, err := net.ParseCIDR(dstCIDR)
				if err != nil {
					klog.ErrorS(err, "error parsing cidr", "cidr", dstCIDR)
					continue
				}
				nr := &netlink.Route{
					LinkIndex: vx.vxlanIface.Attrs().Index,
					Scope:     netlink.SCOPE_UNIVERSE,
					Dst:       ipnet,
					Gw:        via,
					Table:     routeTableID,
					Src:       src,
					Flags:     int(netlink.FLAG_ONLINK),
					// TODO should minus vpn mtu OverHead
					MTU: vx.vxlanIface.Attrs().MTU,
				}
				routes[networkutil.RouteKey(nr)] = nr
			}
		}
	}
	return routes
}

// calRulesOnNonGateway calculates and returns the desired rules on non-gateway node.
// Rules on non-gateway will give raven route table a higher priority than main table in order to bypass the CNI routing rules.
// The rules format are equivalent to the following `ip rule` command:
//   ip rule add from all lookup {routeTableID} prio {rulePriority}
func (vx *vxlan) calRulesOnNonGateway() map[string]*netlink.Rule {
	rules := make(map[string]*netlink.Rule)
	rule := networkutil.NewRavenRule(rulePriority, routeTableID)
	rules[networkutil.RuleKey(rule)] = rule
	return rules
}

// calRouteOnGateway calculates and returns the desired routes on gateway.
// Routes on gateway node are used to configure the reverse-path route for packets from local non-gateway nodes to remote nodes,
// to avoid asymmetric routing.
// The routes entries format are equivalent to the following `ip route` command:
//   ip route add {non_gateway_nodeN_cidr} via {non_gateway_nodeN_raven0_ip} dev raven0 onlink mtu {mtu} table {routeTableID}
func (vx *vxlan) calRouteOnGateway(network *types.Network) map[string]*netlink.Route {
	routes := make(map[string]*netlink.Route)
	for _, v := range network.LocalNodeInfo {
		if types.NodeName(v.NodeName) == vx.nodeName {
			continue
		}
		_, dst, err := net.ParseCIDR(v.Subnet)
		if err != nil {
			klog.ErrorS(err, "error parsing cidr", "cidr", dst)
			continue
		}
		via := vxlanIP(net.ParseIP(v.PrivateIP))
		nr := &netlink.Route{
			LinkIndex: vx.vxlanIface.Attrs().Index,
			Scope:     netlink.SCOPE_UNIVERSE,
			Dst:       dst,
			Gw:        via,
			Table:     routeTableID,
			Flags:     int(netlink.FLAG_ONLINK),
			MTU:       vx.vxlanIface.Attrs().MTU,
		}
		routes[networkutil.RouteKey(nr)] = nr
	}
	return routes
}

// calRulesOnGateway calculates and returns the desired rules on gateway node.
// Rules on gateway node are used to configure route policy for the reverse-path route.
// The rules format are equivalent to the following `ip rule` command:
//   ip rule add from {remote_nodeN_subnet_cidr} lookup {routeTableID} prio {rulePriority}
func (vx *vxlan) calRulesOnGateway(network *types.Network) map[string]*netlink.Rule {
	rules := make(map[string]*netlink.Rule)
	for _, v := range network.RemoteNodeInfo {
		var srcCIDR *net.IPNet
		var err error
		nodeInfo := network.RemoteNodeInfo[types.NodeName(v.NodeName)]
		if nodeInfo == nil {
			klog.Errorf("node %s not found in RemoteNodeInfo", v.NodeName)
			continue
		}
		_, srcCIDR, err = net.ParseCIDR(nodeInfo.Subnet)
		if err != nil {
			klog.ErrorS(err, "error parsing cidr", "cidr", srcCIDR)
			continue
		}
		rule := networkutil.NewRavenRule(rulePriority, routeTableID)
		rule.Src = srcCIDR
		rules[networkutil.RuleKey(rule)] = rule
	}
	return rules
}

// calFDBOnGateway calculates and returns the desired FDB entries on gateway node.
// The FDB entries format are equivalent to the following `bridge fdb append` command:
//   bridge fdb append 00:00:00:00:00:00 dev raven0 dst {non_gateway_nodeN_private_ip} self permanent
func (vx *vxlan) calFDBOnGateway(network *types.Network) map[string]*netlink.Neigh {
	fdbs := make(map[string]*netlink.Neigh)
	for k, v := range network.LocalNodeInfo {
		if vx.nodeName == k {
			continue
		}
		fdbs[v.PrivateIP] = &netlink.Neigh{
			LinkIndex:    vx.vxlanIface.Attrs().Index,
			State:        netlink.NUD_PERMANENT | netlink.NUD_NOARP,
			Type:         netlink.NDA_DST,
			Family:       syscall.AF_BRIDGE,
			Flags:        netlink.NTF_SELF,
			IP:           net.ParseIP(v.PrivateIP),
			HardwareAddr: networkutil.AllZeroMAC,
		}
	}
	return fdbs
}

// calFDBOnNonGateway calculates and returns the desired FDB entries on non-gateway node.
// The FDB entries format are equivalent to the following `bridge fdb append` command:
//   bridge fdb append 00:00:00:00:00:00 dev raven0 dst {gateway_node_private_ip} self permanent
func (vx *vxlan) calFDBOnNonGateway(network *types.Network) map[string]*netlink.Neigh {
	return map[string]*netlink.Neigh{
		network.LocalEndpoint.PrivateIP: {
			LinkIndex:    vx.vxlanIface.Attrs().Index,
			State:        netlink.NUD_PERMANENT | netlink.NUD_NOARP,
			Type:         netlink.NDA_DST,
			Family:       syscall.AF_BRIDGE,
			Flags:        netlink.NTF_SELF,
			IP:           net.ParseIP(network.LocalEndpoint.PrivateIP),
			HardwareAddr: networkutil.AllZeroMAC,
		},
	}
}

func (vx *vxlan) Cleanup() error {
	errList := errorlist.List{}
	if err := networkutil.CleanRulesOnNode(routeTableID); err != nil {
		errList = errList.Append(err)
	}

	if err := networkutil.CleanRoutesOnNode(routeTableID); err != nil {
		errList = errList.Append(err)
	}

	l, err := netlinkutil.LinkByName(vxlanLinkName)
	if _, ok := err.(netlink.LinkNotFoundError); ok {
		return errList.AsError()
	}
	if err != nil {
		errList = errList.Append(fmt.Errorf("error listing routes: %s", err))
		return errList.AsError()
	}
	err = netlink.LinkDel(l)
	if err != nil {
		errList = errList.Append(fmt.Errorf("error deleting vxlan link: %s", err))
	}
	return errList.AsError()
}

func vxlanIP(privateIP net.IP) net.IP {
	privateIP = privateIP.To4()
	vxlanIP := make(net.IP, 4)
	copy(vxlanIP, privateIP)
	vxlanIP[0] = vxlanGwPrefix
	return vxlanIP
}

func (vx *vxlan) isGatewayRole(network *types.Network) bool {
	return network != nil &&
		network.LocalEndpoint != nil &&
		network.LocalEndpoint.NodeName == vx.nodeName
}
